## Libs
library(rpart)
library(cvTools)

## Load configurations 
source('GlobalVars.R')

## Find euclidean distances for two sets of 2D points. Returns a vector 
## with distances for each of the corresponding rows in the sets

euclideanDistances <- function(pointsSet1, pointsSet2) {
	if (length(pointsSet1)!=length(pointsSet2)) {
		stop("Invalid input: lengths of the vectors are not equal");
	}
	xDist = pointsSet1[, 1]-pointsSet2[, 1]
	yDist = pointsSet1[, 2]-pointsSet2[, 2]
	eucDist = sqrt(xDist*xDist+yDist*yDist)
	eucDist
}

## Copies all the files from a source to a target directory 

copyAllFiles <- function(sourceDirectory, targetDirectory) {
	files <- list.files(sourceDirectory, recursive = FALSE);
	lapply(files, 
		function(filePath) {
		path = paste(sourceDirectory, filePath, sep="")
		file.copy(from=path, to=targetDirectory)
    }
  )
}

## Processes the Cohn-Kanade data set and returns a list of paths to labeled emotion files
## Example: findLabeledEmotionFiles(emotionLabels$happy)

findLabeledEmotionFiles <- function(emotionCode, folder = emotionLabelsFolder) {
	files <- list.files(folder, recursive = TRUE)
	emotionLabelsFiles <- c(); 
	lapply(files, 
		function(file) {
			path = paste(folder, file, sep="/")
			if (read.table(path)==emotionCode) {
				emotionLabelsFiles <<- c(emotionLabelsFiles, path)
			}
		}
	)
	emotionLabelsFiles
}


## Processes the Cohn-Kanade data set, extracting the most relevant landmarks files 
## for a particular facial expression
## Example: findAndCopyEmotionFiles(emotionLabels$happy)

findAndCopyEmotionFiles <- function(emotionCode, targetDirectory = outputFolder) {
	files <- findLabeledEmotionFiles(emotionCode);
	lapply(files, 
		function(path) {
			sPos <- regexpr("S[[:digit:]][[:digit:]][[:digit:]]/", path)   
			endPos <- regexpr("/[[:digit:]][[:digit:]][[:digit:]]/", path)
			if (endPos!=-1) {
				endPos <- endPos+4
				copyFromFolder <- substring(path, sPos, endPos)
				copyFromFolder <- paste(landmarksFolder, copyFromFolder, sep="/")
				copyToFolder   <- substring(path, sPos, endPos-4-1)
				newFolderFullPath <- paste(targetDirectory, copyToFolder, sep="/")
				if (!file.exists(newFolderFullPath)) {
					dir.create(newFolderFullPath)
				}
				copyAllFiles(copyFromFolder, newFolderFullPath)
				paste(copyFromFolder, newFolderFullPath, sep="=>")
			} else {
				NA
			}
		}
	)
}

## Creates a set of folders, specified in @folderPathsList, within the @targetDirectory   

createFolders <- function(folderPathsList = emotionFolders, targetDirectory = outputFolder) {
	lapply(folderPathsList, 
		function(folderPath) {
			if (!file.exists(folderPath)) {
				dir.create(folderPath)
				paste(folderPath, "-> folder created")
			}
		}
	)
} 
	
## Processes the list of files, generated by findAndCopyEmotionFiles() function,  
## generating n.dat (netral face landmarks) and em.dat (emotional face landmarks) files for each subject 

preprocessEmotionFilePaths <- function(inputFolderPath = happinessFolder) {
	folders <- list.dirs(inputFolderPath, recursive = FALSE)
	lapply(folders, 
		function(folder) { 
			files <- list.files(folder, recursive = FALSE);
			firstFile <- paste(folder, files[1], sep="/"); 
			lastFile <- paste(folder, files[length(files)], sep="/"); 
			file.copy(from=firstFile, to=paste(folder, "n.dat", sep="/"));
			file.copy(from=lastFile,  to=paste(folder, "em.dat", sep="/"));
		}
	)
}

## Processes landmarks files within the input folder, generating normalized_change_xy.dat 
## file with normalized change between landmarks in n.dat and em.dat files

createNormalizedLandmarkFiles <- function(inputFolderPath = happinessFolder) {
	folders <- list.dirs(inputFolderPath, recursive = FALSE)
	lapply(folders, 
		  function(folder) { 
		  	neutralFace   <- read.table(paste(folder,"n.dat", sep="/"))
		  	emotionalFace <- read.table(paste(folder,"em.dat", sep="/"))
		  	distances     <- emotionalFace - neutralFace
		  	normalizedDistances <- normalizeMatrix(distances)
		  	destinationPath = paste(folder, "normalized_change_xy.dat", sep="/")
		  	file.create(destinationPath, overwrite=TRUE)
		  	write.table(normalizedDistances, file=destinationPath, row.names=FALSE, col.names=FALSE) # ncolumns=2
		  	paste(destinationPath, "created")
		  }
	)
}

loadData <- function(inputFolderPath=faceExpressionsFolder) {
	emotionCode <- 1
	trainingData <- data.frame()
	labelsColumn <- data.frame()
	
	lapply(emotionTitles, 
		function(emotionTitle) {
			emotionFolder <- paste(inputFolderPath, emotionTitle, sep="/")
			folders <- list.dirs(emotionFolder, recursive = FALSE)
		  	cnt <- 0
		  	for (folder in folders) { 
		  	  	normalizedDistances <- read.table(paste(folder,"normalized_change_xy.dat", sep="/"))
		  	  	features <- c(normalizedDistances[, 1], normalizedDistances[, 2])
		  	  	
		  	  	trainingData <<- rbind.data.frame(trainingData, features)
		  	  	labelsColumn <<- rbind.data.frame(labelsColumn, emotionCode)
		  	  	
		  		#cnt <- cnt + 1
		  		#if (cnt == 2) {
		  		#	break
		  		#}
			}
			emotionCode <<- emotionCode + 1  
		}
	)
	trainingData <- cbind.data.frame(trainingData, labelsColumn)
	colnames(trainingData) <- c(paste("X", 1:136, sep=""), "emotion")
	rownames(trainingData) <- NULL
	trainingData
}

fitDTClassifier <- function(dataSet = loadTrainingData()) {
	formula <- emotion ~ X1+X2+X3+X4+X5+X6+X7+X8+X9+X10+X11+X12+X13+X14+X15+X16+X17+X18+X19+X20+X21+X22+X23+X24+X25+X26+X27+X28+X29+X30+X31+X32+X33+X34+X35+X36+X37+X38+X39+X40+X41+X42+X43+X44+X45+X46+X47+X48+X49+X50+X51+X52+X53+X54+X55+X56+X57+X58+X59+X60+X61+X62+X63+X64+X65+X66+X67+X68+X69+X70+X71+X72+X73+X74+X75+X76+X77+X78+X79+X80+X81+X82+X83+X84+X85+X86+X87+X88+X89+X90+X91+X92+X93+X94+X95+X96+X97+X98+X99+X100+X101+X102+X103+X104+X105+X106+X107+X108+X109+X110+X111+X112+X113+X114+X115+X116+X117+X118+X119+X120+X121+X122+X123+X124+X125+X126+X127+X128+X129+X130+X131+X132+X133+X134+X135+X136
	fit <- rpart(formula, method="class", data=dataSet, control=rpart.control(minsplit=1));
	fit
}

# Estimates cross validation for the specified data set, performing splits into
# K subsets. Returns mean accuracy cross validation  

crossValidation <- function(dataSet, K = 5) {
	accuracy <- numeric(0)
	folds    <- cvFolds(nrow(dataSet), K=K)
	for(i in 1:K) {
		train <- dataSet[folds$subsets[folds$which != i], ]
		validation <- dataSet[folds$subsets[folds$which == i], ]
		classifier <- fitDTClassifier(train)
		pred <- predict(classifier, validation, type="class")
		cm   <- table(pred, validation[, 137])
		acc  <- (cm[1,1]+cm[2,2]+cm[3,3]+cm[4,4]+cm[5,5]+cm[6,6]+cm[7,7])/sum(cm)
		accuracy <- rbind(accuracy, acc)
	}
	accuracy
}

# Estimates confusion matrix for the specifed classifier and test data
# Usage example: confusionMatrix(fit, dt, dt[, 137])

confusionMatrix <- function(fittedClassifier, testData, trueLabels) {
	pred <- predict(fittedClassifier, testData, type="class")
	table(trueLabels, pred)
} 

trainTestClassifier <- function(trainFolder=trainingDataFolder, testFolder=testDataFolder) {
	trainData  <- loadData(trainFolder)
	testData   <- loadData(testFolder)
	trueLabels <- testData[, 137]
	fit <- fitDTClassifier(trainData);
	res <- testClassifier(fit, testData, trueLabels)
	res/length(trueLabels)
}

testClassifier <- function(fittedClassifier, inputs, trueLabels) {
	hitsNum  <- 0
	labels <- c(8); 
	for (inputId in 1: nrow(inputs)) {
		probs      <-  predict(fittedClassifier, inputs[inputId, 1:136])
		max        <- -1
		maxLabelId <-  1
		labelId    <-  1  
		
		for (labelProb in probs) {
			if (labelProb > max) {
				max   <- labelProb
				maxLabelId <- labelId
			}
			labelId <- labelId + 1
		}
		labels <- c(labels, maxLabelId)
		if (maxLabelId == trueLabels[inputId]) {
			hitsNum <- hitsNum + 1
		}
	}
	hitsNum
	#labels
}

normalizeMatrix <- function(matrix) {
	col1   <- matrix[, 1]
	col2   <- matrix[, 2]
	matrix[, 1] <- normalizeVector(col1)
	matrix[, 2] <- normalizeVector(col2)
	matrix
}

normalizeVector <- function(vector) {
	s <- sqrt(var(vector))
	normalizedVector <- (vector-mean(vector)) / s
	normalizedVector
}

## Generates a graph representing average landmarks change between neutral and emotional faces from the Cohn-Kanade data set

plotLandmarkChangesSummary <- function() {
	res <- analyzeFaceExpressions()
	Landmark_ID <- 1:length(res)
	Average_Change <- res
	plot(Landmark_ID, Average_Change, col=ifelse(Average_Change>=9, "red", "black"), lwd=4, type='p')
}

## * Part 1: Read input files that describe landmarks positions for neutral and emotional faces
## Reads files in the following way:
## 	1) Scans all the folders in the input folder 
## 	2) Searches for n.dat and em.dat files that store neutral and an emotional expressions
## * Part 2: Find average landmarks change across all the faces 

analyzeFaceExpressions <- function(inputFolderPath = happinessFolder) {
	landmarksFolders <- list.dirs(inputFolderPath, recursive = FALSE)
	sum          <- list()
	neutralSum   <- list()
	emotionalSum <- list()
	cnt <- 1
	     
	lapply(landmarksFolders, 
		function(folder) {
			neutralFace   <- read.table(paste(folder,"n.dat", sep="/"))
			emotionalFace <- read.table(paste(folder,"em.dat", sep="/"))
			distances     <- euclideanDistances(neutralFace, emotionalFace)
			if (cnt==1) {
				sum             <<- distances
				neutralSum      <<- neutralFace
				emotionalSum    <<- emotionalFace
			} else {
				sum          <<- sum + distances
				neutralSum   <<- neutralSum + neutralFace
				emotionalSum <<- emotionalSum + emotionalFace
			}
			cnt <<- cnt + 1
			if (cnt == 100) {
				cnt <<- 1
				
			}
		}
	)
	## Obtain the average change of landmarks across all faces
	neutralAvg     <- neutralSum / cnt
	emotionalAvg   <- emotionalSum / cnt  
  
	## Constructing Face maps - visualization characterizing average changes of landmarks across all faces 
	dataToPlot <- neutralAvg
	dataToPlot <- rbind(dataToPlot, emotionalAvg)
	len <- nrow(dataToPlot)
	dataToPlot <- cbind(dataToPlot, rowId=1:len)
	plot(dataToPlot[, 1], -dataToPlot[, 2], col=ifelse(dataToPlot$rowId > len/2, "red", "black"), lwd=4, type='p')
  
	## Visualizations:
	## plot(neutralAvg[, 1], neutralAvg[, 2])
	## plot(emotionalAvg[, 1], emotionalAvg[, 2])
	## plot(AU_ID, Average_Change, col=ifelse(Average_Change>=9, "orange", "black"), lwd=4, type='p')
  
	## Obtain the average change of landmarks across all faces
	totalAvg <- sum / cnt
	totalAvg
}